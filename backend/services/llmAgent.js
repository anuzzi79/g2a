// backend/services/llmAgent.js
import OpenAI from 'openai';
import fs from 'fs/promises';

let openaiClient = null;

/**
 * Inizializza il client OpenAI
 */
function getOpenAIClient() {
  if (!openaiClient) {
    const apiKey = process.env.OPENAI_API_KEY;
    if (!apiKey) {
      throw new Error('OPENAI_API_KEY non configurata nel file .env');
    }
    openaiClient = new OpenAI({ apiKey });
  }
  return openaiClient;
}

/**
 * Parsing di una frase Gherkin per estrarre parti di senso compiuto
 */
export async function parseGherkinSentence(sentence, context = {}) {
  const client = getOpenAIClient();
  const model = process.env.OPENAI_MODEL || 'gpt-4';

  // DISABILITATO: Rimozione riferimenti a page objects
  const contextStr = '';

  const prompt = `Analizza questa frase Gherkin e estrai le parti di senso compiuto che rappresentano azioni o verifiche automatizzabili.

Frase: "${sentence}"
${contextStr}

Per ogni parte di senso compiuto, identifica:
1. Il tipo di azione (click, type, verify, navigate, wait, etc.)
2. L'elemento target (se presente)
3. Il valore o stato atteso (se presente)

Rispondi con un JSON che contiene un campo "parts" che Ã¨ un array. Ogni elemento dell'array deve avere:
{
  "type": "azione",
  "target": "elemento o selettore",
  "value": "valore o testo atteso",
  "description": "descrizione breve della parte"
}

Esempio di risposta JSON:
{
  "parts": [
    {"type": "navigate", "target": null, "value": "/path/to/page", "description": "Naviga al path specificato"},
    {"type": "click", "target": "Action/Copy", "value": null, "description": "Clicca sul pulsante Action/Copy"},
    {"type": "verify", "target": "modal", "value": "aperto", "description": "Verifica che il modal sia aperto"}
  ]
}

IMPORTANTE: Rispondi SOLO con il JSON valido, senza testo aggiuntivo.`;

  try {
    const response = await client.chat.completions.create({
      model,
      messages: [
        { role: 'system', content: 'Sei un esperto di automazione test e parsing Gherkin. Analizza le frasi e estrai azioni automatizzabili. Rispondi SEMPRE con un JSON valido che contiene un campo "parts" che Ã¨ un array.' },
        { role: 'user', content: prompt }
      ],
      temperature: 0.3,
      response_format: { type: 'json_object' }
    });

    const content = response.choices[0].message.content;
    const parsed = JSON.parse(content);
    
    // Supporta sia array diretto che oggetto con campo "parts"
    let parts = [];
    if (Array.isArray(parsed)) {
      parts = parsed;
    } else if (parsed.parts && Array.isArray(parsed.parts)) {
      parts = parsed.parts;
    } else if (parsed.actions && Array.isArray(parsed.actions)) {
      parts = parsed.actions;
    }
    
    return parts;
  } catch (error) {
    console.error('Errore parsing Gherkin:', error);
    throw error;
  }
}

/**
 * Segmenta un enunciato GWT in chunk semantici puri
 * Compatibile con lo schema EC Objects esistente
 */
export async function segmentSemanticChunks(text, phase = 'given') {
  const client = getOpenAIClient();
  const model = process.env.OPENAI_MODEL || 'gpt-4';

  const prompt = `Sei un esperto linguista specializzato nell'analisi semantica di test cases.

ENUNCIATO DA SEGMENTARE:
"${text}"

FASE: ${phase.toUpperCase()}

TASK:
Segmenta questo enunciato in CHUNK SEMANTICI PURI che rappresentano concetti completi e indipendenti.

REGOLE:
1. RIMUOVI completamente: Given, When, Then, And, Or, But (case-insensitive all'inizio o nel mezzo)
2. Ogni chunk deve essere una proposizione con significato autonomo
3. Mantieni articoli, preposizioni e connettivi INTERNI ai chunk
4. Dividi dove ci sono congiunzioni che separano concetti diversi
5. Rimuovi virgole, punti e virgola che separano le clausole

ESEMPIO:
Input: "Given I have requested a PDF report from the Checklists and the report was successfully generated by the system"

Output:
{
  "chunks": [
    {
      "text": "I have requested a PDF report from the Checklists",
      "semanticType": "action"
    },
    {
      "text": "the report was successfully generated by the system",
      "semanticType": "state"
    }
  ]
}

TIPI SEMANTICI:
- "action": azione eseguita dall'utente/sistema
- "state": stato o condizione
- "verification": verifica o aspettativa
- "precondition": precondizione/setup
- "result": risultato/effetto

Rispondi SOLO con JSON nel formato:
{
  "chunks": [
    {"text": "...", "semanticType": "..."}
  ]
}`;

  try {
    const response = await client.chat.completions.create({
      model,
      messages: [
        { 
          role: 'system', 
          content: 'Sei un esperto linguista. Segmenti frasi in unitÃ  semantiche atomiche. Rispondi SEMPRE con JSON valido con campo "chunks" (array).' 
        },
        { role: 'user', content: prompt }
      ],
      temperature: 0.2,
      response_format: { type: 'json_object' }
    });

    const content = response.choices[0].message.content;
    const parsed = JSON.parse(content);
    
    // Valida e pulisci chunks
    const chunks = (parsed.chunks || [])
      .map(chunk => ({
        text: chunk.text?.trim() || '',
        semanticType: chunk.semanticType || 'unknown'
      }))
      .filter(chunk => chunk.text.length > 0);
    
    return chunks;
  } catch (error) {
    console.error('[Semantic Segmentation] Errore:', error);
    throw error;
  }
}

/**
 * Suggerisce selettore/azione per una parte di senso compiuto
 */
export async function suggestAutomation(actionPart, context = {}, conversationHistory = []) {
  const client = getOpenAIClient();
  const model = process.env.OPENAI_MODEL || 'gpt-4';

  // DISABILITATO: Rimozione riferimenti a page objects nel reasoning
  // Le page objects non vengono piÃ¹ usate nel reasoning
  let contextInfo = '';
  
  // RIMOSSO: contesto selettori e metodi dalle page objects
  // Il reasoning ora si basa esclusivamente sul Wide Reasoning sui test case esistenti

  const historyStr = conversationHistory.length > 0
    ? `\n\nStoria conversazione:\n${conversationHistory.map((msg, i) => `${i + 1}. ${msg.role}: ${msg.content}`).join('\n')}`
    : '';

  const prompt = `L'utente vuole automatizzare questa azione:
Tipo: ${actionPart.type}
Target: ${actionPart.target || 'non specificato'}
Valore: ${actionPart.value || 'non specificato'}
Descrizione: ${actionPart.description}
${contextInfo}${historyStr}

Suggerisci:
1. Il miglior selettore Cypress da usare (es: cy.get('...'), cy.contains('...'))
2. Il comando Cypress appropriato (click, type, should, etc.)
3. Eventuali considerazioni o alternative

Rispondi in formato JSON:
{
  "suggestion": "codice Cypress suggerito completo",
  "selector": "selettore suggerito",
  "command": "comando Cypress",
  "explanation": "spiegazione breve del perchÃ© questa soluzione",
  "alternativeSelectors": ["alternativa1", "alternativa2"],
  "confidence": 0.8,
  "needsClarification": false,
  "clarificationQuestion": null
}

Se hai bisogno di piÃ¹ informazioni dall'utente, imposta needsClarification: true e fornisci una clarificationQuestion.`;

  try {
    const response = await client.chat.completions.create({
      model,
      messages: [
        { 
          role: 'system', 
          content: 'Sei un esperto di automazione Cypress. Suggerisci il miglior codice per automatizzare azioni basandoti sul contesto fornito.' 
        },
        { role: 'user', content: prompt }
      ],
      temperature: 0.5,
      response_format: { type: 'json_object' }
    });

    const content = response.choices[0].message.content;
    const suggestion = JSON.parse(content);
    
    return suggestion;
  } catch (error) {
    console.error('Errore suggerimento automazione:', error);
    throw error;
  }
}

/**
 * Chat interattiva per raffinare una soluzione
 */
export async function chatWithAI(message, actionPart, context = {}, conversationHistory = [], wideReasoning = false, similarTestCases = []) {
  const client = getOpenAIClient();
  const model = process.env.OPENAI_MODEL || 'gpt-4';

  // DISABILITATO: Rimozione riferimenti a page objects nel reasoning
  // Le page objects non vengono piÃ¹ usate nel reasoning
  // Il Wide Reasoning sui test case esistenti Ã¨ la strategia principale
  let optimizedContext = '';
  
  // RIMOSSO: contesto selettori e metodi dalle page objects
  // Il reasoning ora si basa esclusivamente sul Wide Reasoning sui test case esistenti

  // AGGIUNGI CONTESTO DELLE ALTRE FASI
  let otherPhasesInfo = '';
  if (context && context.otherPhases) {
    const phases = [];
    if (context.otherPhases.given) {
      phases.push(`GIVEN: "${context.otherPhases.given.text}"${context.otherPhases.given.code ? `\n  Codice giÃ  generato:\n  ${context.otherPhases.given.code.split('\n').map(l => '  ' + l).join('\n')}` : ' (non ancora generato)'}`);
    }
    if (context.otherPhases.when) {
      phases.push(`WHEN: "${context.otherPhases.when.text}"${context.otherPhases.when.code ? `\n  Codice giÃ  generato:\n  ${context.otherPhases.when.code.split('\n').map(l => '  ' + l).join('\n')}` : ' (non ancora generato)'}`);
    }
    if (context.otherPhases.then) {
      phases.push(`THEN: "${context.otherPhases.then.text}"${context.otherPhases.then.code ? `\n  Codice giÃ  generato:\n  ${context.otherPhases.then.code.split('\n').map(l => '  ' + l).join('\n')}` : ' (non ancora generato)'}`);
    }
    
    if (phases.length > 0) {
      otherPhasesInfo = `\n\nâš ï¸ IMPORTANTE: Questo test case ha altre fasi giÃ  definite:\n${phases.join('\n\n')}\n\nQuando generi il codice per questa fase, assicurati che sia compatibile e si integri bene con le altre fasi. Il codice che generi verrÃ  combinato in sequenza con le altre fasi in un unico test Cypress.`;
    }
  }

  // AGGIUNGI CONTESTO WIDE REASONING CON TEST CASE SIMILI
  let wideReasoningInfo = '';
  if (wideReasoning && similarTestCases && similarTestCases.length > 0) {
    console.log(`[Backend Wide Reasoning] Ricevuti ${similarTestCases.length} test case simili`);
    console.log(`[Backend Wide Reasoning] Test case IDs:`, similarTestCases.map(tc => tc.id));
    
    wideReasoningInfo = `\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n`;
    wideReasoningInfo += `ðŸ” WIDE REASONING MODE ATTIVO - HAI ACCESSO DIRETTO AL REPOSITORY DI TEST\n`;
    wideReasoningInfo += `â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n`;
    wideReasoningInfo += `âœ… SÃŒ, HAI ACCESSO DIRETTO AI TEST CASE DEL REPOSITORY!\n\n`;
    wideReasoningInfo += `Ho trovato ${similarTestCases.length} test case che hanno giÃ  risolto problemi SIMILI a quello attuale.\n`;
    wideReasoningInfo += `Questi test case sono REALI e sono stati giÃ  implementati nel repository. DEVI usarli come riferimento concreto.\n\n`;
    wideReasoningInfo += `âš ï¸ NON dire "non ho accesso diretto al repository" - HAI ACCESSO a questi test case:\n\n`;
    
    similarTestCases.forEach((similar, idx) => {
      wideReasoningInfo += `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n`;
      wideReasoningInfo += `ðŸ“‹ ESEMPIO #${idx + 1}: Test Case ID ${similar.id} (SimilaritÃ : ${(similar.similarity * 100).toFixed(1)}%)\n`;
      wideReasoningInfo += `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n`;
      
      wideReasoningInfo += `ðŸ“ PROBLEMA RISOLTO:\n`;
      const sourcePhase = similar.blockType || actionPart.type || 'CURRENT';
      wideReasoningInfo += `Fase ${sourcePhase.toUpperCase()}: "${similar.blockText}"\n`;
      if (sourcePhase !== actionPart.type) {
        wideReasoningInfo += `âš ï¸ NOTA: Questo codice proviene dalla fase ${sourcePhase.toUpperCase()}, ma puÃ² essere adattato per la fase ${actionPart.type?.toUpperCase() || 'CURRENT'} corrente.\n`;
      }
      wideReasoningInfo += `\n`;
      
      if (similar.allPhases) {
        wideReasoningInfo += `ðŸ“‹ CONTESTO COMPLETO DEL TEST CASE:\n`;
        if (similar.allPhases.given) wideReasoningInfo += `  â€¢ GIVEN: "${similar.allPhases.given}"\n`;
        if (similar.allPhases.when) wideReasoningInfo += `  â€¢ WHEN: "${similar.allPhases.when}"\n`;
        if (similar.allPhases.then) wideReasoningInfo += `  â€¢ THEN: "${similar.allPhases.then}"\n`;
        wideReasoningInfo += `\n`;
      }
      
      if (similar.code) {
        wideReasoningInfo += `âœ… SOLUZIONE IMPLEMENTATA (USA QUESTO COME RIFERIMENTO):\n`;
        wideReasoningInfo += `\`\`\`javascript\n`;
        wideReasoningInfo += similar.code.split('\n').map(l => l).join('\n');
        wideReasoningInfo += `\n\`\`\`\n\n`;
      }
      
      if (similar.allCode && (similar.allCode.given || similar.allCode.when || similar.allCode.then)) {
        wideReasoningInfo += `ðŸ“¦ CODICE COMPLETO DEL TEST CASE (per contesto):\n`;
        if (similar.allCode.given) {
          wideReasoningInfo += `\n// GIVEN:\n${similar.allCode.given.substring(0, 500)}${similar.allCode.given.length > 500 ? '...' : ''}\n`;
        }
        if (similar.allCode.when) {
          wideReasoningInfo += `\n// WHEN:\n${similar.allCode.when.substring(0, 500)}${similar.allCode.when.length > 500 ? '...' : ''}\n`;
        }
        if (similar.allCode.then) {
          wideReasoningInfo += `\n// THEN:\n${similar.allCode.then.substring(0, 500)}${similar.allCode.then.length > 500 ? '...' : ''}\n`;
        }
        wideReasoningInfo += `\n`;
      }
    });
    
    wideReasoningInfo += `\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n`;
    wideReasoningInfo += `ðŸ“ ISTRUZIONI OBBLIGATORIE PER LA TUA RISPOSTA:\n`;
    wideReasoningInfo += `â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n`;
    wideReasoningInfo += `1. âœ… INIZIA la tua risposta dicendo: "SÃ¬, ho trovato nei test case simili..." o "Basandomi sul Test Case #X..."\n\n`;
    wideReasoningInfo += `2. âœ… NON dire mai "non ho accesso diretto" - HAI ACCESSO a questi test case reali sopra!\n\n`;
    wideReasoningInfo += `3. âœ… CITARE ESPLICITAMENTE gli ID dei test case che usi (es: "Nel Test Case #${similarTestCases[0]?.id || 'X'} ho visto che...").\n\n`;
    wideReasoningInfo += `4. âœ… MOSTRARE il codice specifico preso dai test case simili, spiegando cosa fa e come l'hai adattato.\n\n`;
    wideReasoningInfo += `5. âœ… Se l'utente chiede di "ritrovare" o "cercare" qualcosa, DEVI cercare nei test case sopra e citare esattamente dove l'hai trovato.\n\n`;
    wideReasoningInfo += `6. âœ… IDENTIFICA i pattern comuni (selettori CSS, metodi Cypress, sequenze di azioni) dai test case simili e riutilizzali.\n\n`;
    wideReasoningInfo += `7. âŒ NON dare risposte generiche come "potresti aver fatto" o "suggerisco" - USA i test case sopra come FONTE DIRETTA!\n\n`;
    wideReasoningInfo += `\nâš ï¸ IMPORTANTE: L'utente HA RICHIESTO ESPLICITAMENTE di cercare in altri test case. DEVI rispondere con riferimenti concreti ai test case sopra!\n`;
    wideReasoningInfo += `â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n`;
  } else if (wideReasoning) {
    wideReasoningInfo = `\n\nâš ï¸ WIDE REASONING MODE ATTIVO ma nessun test case simile trovato.\n`;
    wideReasoningInfo += `L'utente ha richiesto di basare la soluzione su casi simili, ma non ci sono test case simili disponibili nel repository.\n`;
    wideReasoningInfo += `Procedi con una soluzione standard basata sul contesto disponibile.\n\n`;
  }

  const messages = [
    {
      role: 'system',
      content: `Sei un assistente AI per l'automazione di test Cypress. Aiuta l'utente a trovare la migliore soluzione per automatizzare:

Azione: ${actionPart.type || 'sconosciuta'} - ${actionPart.description || 'da determinare'}
Target: ${actionPart.target || 'da determinare'}
Valore: ${actionPart.value || 'da determinare'}
${optimizedContext}${otherPhasesInfo}${wideReasoningInfo}

IMPORTANTE: Quando generi codice Cypress, genera SOLO il codice della fase corrente (${actionPart.type ? actionPart.type.toUpperCase() : 'CURRENT'}), senza wrapper describe/it. Il codice verrÃ  automaticamente combinato con le altre fasi. Inizia sempre con un commento che indica la fase (es: // ===== GIVEN PHASE =====) e un cy.log() che descrive la fase.

${actionPart.type === 'when' || actionPart.type === 'then' ? 'âš ï¸ CRITICO: NON includere cy.visit() in questa fase. La navigazione alla pagina Ã¨ giÃ  stata gestita nella fase GIVEN. Questa fase contiene SOLO azioni (WHEN) o verifiche (THEN).' : actionPart.type === 'given' ? 'La fase GIVEN puÃ² contenere cy.visit() se necessario per navigare alla pagina iniziale.' : ''}

Usa il contesto fornito per suggerire soluzioni concrete.${wideReasoning && similarTestCases && similarTestCases.length > 0 ? `\n\nðŸŽ¯ PRIORITÃ€ ASSOLUTA: L'utente ti ha chiesto di cercare in altri test case. HAI ACCESSO DIRETTO a ${similarTestCases.length} test case reali sopra. DEVI:\n- Cercare nei test case sopra quello che l'utente richiede\n- Citare ESPLICITAMENTE gli ID dei test case\n- Mostrare il codice specifico trovato\n- NON dire mai "non ho accesso" - HAI ACCESSO COMPLETO ai test case sopra!\n\nâš ï¸ Se l'utente chiede "Riesci a ritrovarli?" o "Cerca in altri test case", DEVI cercare nei test case simili sopra e rispondere con riferimenti concreti!` : ''}`
    },
    ...conversationHistory.map(msg => ({
      role: msg.role,
      content: msg.content
    })),
    {
      role: 'user',
      content: message
    }
  ];

  try {
    const response = await client.chat.completions.create({
      model,
      messages,
      temperature: 0.7
    });

    return response.choices[0].message.content;
  } catch (error) {
    console.error('Errore chat AI:', error);
    throw error;
  }
}
